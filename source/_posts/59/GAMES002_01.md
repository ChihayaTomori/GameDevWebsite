---
title: GAMES002第一课 Linux + Shell
date: 2024-07-14
updated: 2024-07-14
permalink: articles/59/GAMES002_01/
categories: 59
tags: [Linux]
---
GAMES002-图形学研发基础工具第一课 Linux + Shell
<!--More-->

[课程链接](https://www.bilibili.com/video/BV1cC411L7uG)

课程并没有教怎么装一个Linux系统
## Linux基础

### Shell

#### Shell 是如何工作的
- 本质是调用程序
	- 例如前面的 echo 实际上是系统内置的程序
- 命令行第一个词是程序名称，随后是参数
	- 词之间用空格分隔
- 敲下回车之后会开启一个子进程运行相应程序
#### Shell 如何找到要调用的程序
- 环境变量 PATH
- 每一个路径就是它的搜索空间，Shell 会遍历 PATH 中的所有位置来搜索

---

### 绝对路径与相对路径
- 绝对路径以'/'开头（' / ' 本身表示根目录）
- 相对路径从当前路径出发 （显示在用户名之后，可以用pwd命令查看）
- 特殊路径
	- ' . '：当前路径，' .. '：父路径（类似Windows里面的后退）
	- ' - '：上次到达的路径
	- ' ~ '：home所在的路径
**Linux 一切皆文件**：Linux 将所有资源都视为文件来管理，包括硬件设备、网络套接字等。带来的好处就是不同种类的资源可以用同种方式管理。例如 /sys/class 目录下的每个文件夹代表一种设备，其中的文件则表示设备的各种参数。
---
### 重定向与管道

Linux有三种标准I/O流：
- 标准输入（stdin）：文件描述符为0
- 标准输出（stdout）：文件描述符为1
- 标准错误（stderr）：文件描述符为2
- Shell 中的每个指令都有输入、输出流
	- 默认输入流读取键盘输入，输出流显示到屏幕
	- ' < '改变输入流， ' > '改变输出流
	- ' >> '在文件末尾追加

#### 输出重定向

`>`：覆盖写入 `2>`：覆盖写入`&>`：覆盖写入
`>>`：追加写入`2>>`：追加写入`&>>`：追加写入
将命令的标准输出重定向到文件。

##### 覆盖写入 (Overwrite)

覆盖写入会将文件的内容替换为新的输出。如果文件已经存在，之前的内容会被删除，文件中只会保留新的内容。如果文件不存在，则会创建一个新文件。
例如：
`echo "Hello, World!" > file.txt`
如果`file.txt`已经存在，其内容将被替换为`"Hello, World!"`。

##### 追加写入 (Append)

追加写入不会删除文件的现有内容，而是在文件末尾添加新的输出。如果文件不存在，则会创建一个新文件。
将命令的输出追加写入到文件中：
`echo "Hello, again!" >> file.txt`
如果`file.txt`已经存在，`"Hello, again!"`会被添加到文件末尾，文件原有内容保持不变。

---

#### 管道 ' | '

a | b，a 的输出作为 b 的输入

`cat blank.txt | grep eth` 
`grep eth`会在该文件中查找包含`eth`的行并输出这些行

`echo something | sudo tee blank.txt`
`sudo` 只以管理员权限执行紧接着的那个指令
`tee` 用于读取标准输入并将其内容同时写入标准输出和一个或多个文件。

`ls | grep "pattern"` 
这个命令会列出当前目录中的所有文件，并将结果过滤出包含`pattern`的行。

`cat file.txt | sort | uniq`
将`cat`命令的输出通过管道传递给`sort`命令，再通过管道传递给`uniq`命令。
这个命令会读取`file.txt`的内容，将其排序，然后去除重复的行。

---

### 权限

- 用 ' ls -l '可以查看权限位
![ICON](articles/59/GAMES002_01/01.png)
- 用 ' chmod ' 修改权限位有两种方式
![ICON](articles/59/GAMES002_01/02.png)
- chmod 用户 +/- 权限 文件名
- chmod 权限对应八进制数 文件名 （r=4 w=2 x=1）
	- `chmod 754 myfile.txt` 
	1. 所有者权限 `rwx` = 7
	2. 组用户权限 `r-x` = 5
	3. 其他用户权限 `r--` = 4
---

### 变量

- 赋值：变量名=字符串
	- 赋值只会添加 Shell 变量，关闭Shell后就会消失
	- 赋值语句前面加 export 可以添加环境变量，但是是一次性的
	- foo = bar 有空格是错误的
访问变量的内容：变量前面加上 `$` 符号。 `$foo`，将 `foo` 的值替换掉 `$foo`
- env - 查看环境变量
- set - 环境变量 + Shell 变量 
- 永久添加：
	- 将 export 赋值语句放入 home 下的 .bashrc 文件中
	- source ~/.bashrc
该文件前面有` . ` ，代表它是隐藏文件，用 `ls -a` 才能看到

---

### 命令替换与进程替换

当我们希望将指令的输出结果作为参数时
- 命令替换：`$( command )`将指令执行后的输出替换掉
```
users=$(who | wc -l)
echo "There are $users users currently logged in."
```

这个示例中，`who | wc -l`命令用于统计当前登录用户数，并将结果赋值给变量`users`，然后通过`echo`命令输出。

- 进程替换：**输入替换**：`<(command)` **输出替换**：`>(command)`
	- 将指令的输出重定向到临时文件，并用临时文件名替换 <( command ) 
	- 它允许你使用命令的输出作为另一个命令的输入，而不需要显式地使用临时文件

例如 `diff <(ls dir1) <(ls dir2)`
在这个示例中，`<(ls dir1)`和`<(ls dir2)`将两个`ls`命令的输出作为文件名传递给`diff`命令。

---

### Shell 脚本

脚本语言：脚本语言是指不需要编译而直接由解释器逐行执行的一类编程语言。源代码在运行时由解释器动态解析和执行。例如Bash 与 python 都是脚本语言 。
编译语言：程序执行之前需要通过编译器将源代码转换成机器码（可执行文件）的一类编程语言。编译过程将源代码一次性转换为目标机器能够直接执行的代码。


 \#！ Sharp-bang 符号
- 放在脚本文件的开头，同一行后面跟着解释器的路径
- 实际运行时会调用 sharp-bang 后的解释器，并将脚本文件名作为参数
-  `#` 表示注释 
- 可以直接用 `./script-name` 执行脚本
一个典型的shell脚本文件以`#!/bin/sh`或`#!/bin/bash`开始，这一行称为shebang / sharp-bang，用来指明使用哪个shell来执行脚本。`#!` 后面添加解释器的路径与名称。
例如名为`copy.py`的文件第一行为`#!/usr/bin/env python3`，当我们用`./script-name`运行脚本时，相当于`python3 copy.py` 。 
后续的行则是具体的命令和逻辑。

